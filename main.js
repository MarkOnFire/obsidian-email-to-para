/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => EmailToParaPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/SettingsTab.ts
var import_obsidian = require("obsidian");
var EmailToParaSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Email to PARA Sync Settings" });
    containerEl.createEl("h3", { text: "OAuth Application Setup" });
    containerEl.createEl("p", { text: "Before connecting accounts, you need to register OAuth applications with Google and Microsoft. This allows the plugin to securely access your emails." });
    containerEl.createEl("p", { text: "Please refer to the plugin's README.md for detailed, step-by-step instructions on how to create these applications and obtain your Client IDs." });
    const oauthLinksEl = containerEl.createEl("ul");
    oauthLinksEl.createEl("li", { text: "Google Cloud Console (for Gmail): " }).createEl("a", {
      href: "https://console.cloud.google.com",
      text: "https://console.cloud.google.com"
    });
    oauthLinksEl.createEl("li", { text: "Azure Portal (for Outlook): " }).createEl("a", {
      href: "https://portal.azure.com",
      text: "https://portal.azure.com"
    });
    containerEl.createEl("h3", { text: "Account Management" });
    new import_obsidian.Setting(containerEl).setName("Enable Gmail Sync").setDesc("Toggle to enable or disable synchronization with Gmail.").addToggle((toggle) => toggle.setValue(this.plugin.settings.gmail.enabled).onChange(async (value) => {
      this.plugin.settings.gmail.enabled = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.gmail.enabled) {
      new import_obsidian.Setting(containerEl).setName("Gmail Client ID").setDesc("Enter your Google OAuth Client ID for this plugin.").addText((text) => text.setPlaceholder("Enter your Client ID").setValue(this.plugin.settings.gmail.clientId).onChange(async (value) => {
        this.plugin.settings.gmail.clientId = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("Connect Gmail Account").setDesc("Click to authenticate with your Gmail account.").addButton((button) => button.setButtonText(this.plugin.gmailProvider.isAuthenticated() ? "Reconnect" : "Connect").setCta().onClick(async () => {
        try {
          await this.plugin.gmailProvider.authenticate();
          await this.plugin.saveSettings();
          this.display();
        } catch (e) {
          console.error("Gmail authentication error:", e);
        }
      }));
      const statusText = this.plugin.gmailProvider.isAuthenticated() ? "\u2705 Connected" : "\u274C Not Connected";
      containerEl.createEl("p", { text: `Gmail Status: ${statusText}` });
    }
    containerEl.createEl("h3", { text: "Outlook Settings" });
    new import_obsidian.Setting(containerEl).setName("Enable Outlook Sync").setDesc("Toggle to enable or disable synchronization with Outlook.").addToggle((toggle) => toggle.setValue(this.plugin.settings.outlook.enabled).onChange(async (value) => {
      this.plugin.settings.outlook.enabled = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.outlook.enabled) {
      new import_obsidian.Setting(containerEl).setName("Outlook Client ID").setDesc("Enter your Microsoft OAuth Client ID for this plugin.").addText((text) => text.setPlaceholder("Enter your Client ID").setValue(this.plugin.settings.outlook.clientId).onChange(async (value) => {
        this.plugin.settings.outlook.clientId = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("Connect Outlook Account").setDesc("Click to authenticate with your Outlook account.").addButton((button) => button.setButtonText("Connect").setCta().onClick(async () => {
        new Notification("Outlook Connection", { body: "Initiating Outlook OAuth flow (not yet implemented)" });
        console.log("Initiating Outlook OAuth flow...");
      }));
      containerEl.createEl("p", { text: `Outlook Status: ${this.plugin.settings.outlook.encryptedTokenBlob ? "Connected" : "Not Connected"}` });
    }
    containerEl.createEl("h3", { text: "Synchronization Settings" });
    new import_obsidian.Setting(containerEl).setName("Sync Interval").setDesc("How often (in minutes) the plugin should check for new starred/flagged emails.").addText((text) => text.setPlaceholder("e.g., 30").setValue(this.plugin.settings.sync.intervalMinutes.toString()).onChange(async (value) => {
      const parsed = parseInt(value, 10);
      if (!isNaN(parsed) && parsed > 0) {
        this.plugin.settings.sync.intervalMinutes = parsed;
        await this.plugin.saveSettings();
      } else {
        new Notification("Invalid Input", { body: "Sync interval must be a positive number." });
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Inbox Folder").setDesc('The folder where new email notes will be created (e.g., "0 - INBOX").').addText((text) => text.setPlaceholder("0 - INBOX").setValue(this.plugin.settings.sync.inboxFolder).onChange(async (value) => {
      this.plugin.settings.sync.inboxFolder = value;
      await this.plugin.saveSettings();
    }));
  }
};

// src/types.ts
var DEFAULT_SETTINGS = {
  gmail: {
    enabled: false,
    clientId: ""
  },
  outlook: {
    enabled: false,
    clientId: ""
  },
  sync: {
    intervalMinutes: 30,
    inboxFolder: "0 - INBOX"
  }
};

// src/SyncStateManager.ts
var DEFAULT_SYNC_STATE = {
  lastSyncTime: 0,
  syncedIds: {}
};
var SyncStateManager = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.state = { ...DEFAULT_SYNC_STATE };
    this.statePath = `${this.plugin.manifest.dir}/.sync-state.json`;
  }
  /**
   * Load state from disk
   */
  async load() {
    try {
      const adapter = this.plugin.app.vault.adapter;
      if (await adapter.exists(this.statePath)) {
        const data = await adapter.read(this.statePath);
        this.state = JSON.parse(data);
      } else {
        this.state = { ...DEFAULT_SYNC_STATE };
      }
    } catch (e) {
      console.error("Failed to load sync state:", e);
      this.state = { ...DEFAULT_SYNC_STATE };
    }
  }
  /**
   * Save state to disk
   */
  async save() {
    try {
      const adapter = this.plugin.app.vault.adapter;
      await adapter.write(this.statePath, JSON.stringify(this.state, null, 2));
    } catch (e) {
      console.error("Failed to save sync state:", e);
    }
  }
  /**
   * Check if a message ID has already been synced
   */
  isSynced(id) {
    return !!this.state.syncedIds[id];
  }
  /**
   * Mark a message ID as synced
   */
  async addSynced(id) {
    this.state.syncedIds[id] = Date.now();
    await this.save();
  }
  /**
   * Get the timestamp of the last successful sync
   */
  getLastSyncTime() {
    return this.state.lastSyncTime;
  }
  /**
   * Update the last sync timestamp
   */
  async setLastSyncTime(time) {
    this.state.lastSyncTime = time;
    await this.save();
  }
  /**
   * Get the full state object (readonly-ish)
   */
  getState() {
    return this.state;
  }
};

// src/OAuthServer.ts
var http = __toESM(require("http"));
var OAuthServer = class {
  constructor() {
    this.server = null;
    this.port = 42813;
  }
  // Fixed port for OAuth redirect URI
  /**
   * Start the OAuth callback server
   * Returns the port number it's listening on
   */
  async start() {
    return new Promise((resolve, reject) => {
      this.server = http.createServer();
      this.server.listen(this.port, "127.0.0.1", () => {
        const address = this.server.address();
        if (address && typeof address === "object") {
          this.port = address.port;
          console.log(`OAuth callback server listening on http://127.0.0.1:${this.port}`);
          resolve(this.port);
        } else {
          reject(new Error("Failed to get server port"));
        }
      });
      this.server.on("error", (err) => {
        console.error("OAuth server error:", err);
        reject(err);
      });
    });
  }
  /**
   * Wait for OAuth callback with authorization code
   * Returns a promise that resolves when callback is received
   * @param expectedState - The state parameter to verify (CSRF protection)
   * @param timeoutMs - How long to wait for callback (default: 5 minutes)
   */
  waitForCallback(expectedState, timeoutMs = 5 * 60 * 1e3) {
    return new Promise((resolve, reject) => {
      if (!this.server) {
        reject(new Error("Server not started"));
        return;
      }
      const timeout = setTimeout(() => {
        this.stop();
        reject(new Error("OAuth flow timed out after 5 minutes"));
      }, timeoutMs);
      this.server.on("request", (req, res) => {
        const url = new URL(req.url, `http://127.0.0.1:${this.port}`);
        if (url.pathname === "/callback") {
          const code = url.searchParams.get("code");
          const state = url.searchParams.get("state");
          const error = url.searchParams.get("error");
          const errorDescription = url.searchParams.get("error_description");
          if (error) {
            clearTimeout(timeout);
            res.writeHead(400, { "Content-Type": "text/html" });
            res.end(`
                            <html>
                                <body style="font-family: system-ui; padding: 40px; text-align: center;">
                                    <h1>\u274C Authentication Failed</h1>
                                    <p>${error}: ${errorDescription || "Unknown error"}</p>
                                    <p>You can close this window and try again.</p>
                                </body>
                            </html>
                        `);
            this.stop();
            reject(new Error(`OAuth error: ${error} - ${errorDescription}`));
            return;
          }
          if (!code || !state) {
            clearTimeout(timeout);
            res.writeHead(400, { "Content-Type": "text/html" });
            res.end(`
                            <html>
                                <body style="font-family: system-ui; padding: 40px; text-align: center;">
                                    <h1>\u274C Invalid Callback</h1>
                                    <p>Missing authorization code or state parameter.</p>
                                    <p>You can close this window and try again.</p>
                                </body>
                            </html>
                        `);
            this.stop();
            reject(new Error("Missing code or state in OAuth callback"));
            return;
          }
          if (state !== expectedState) {
            clearTimeout(timeout);
            res.writeHead(403, { "Content-Type": "text/html" });
            res.end(`
                            <html>
                                <body style="font-family: system-ui; padding: 40px; text-align: center;">
                                    <h1>\u274C Security Error</h1>
                                    <p>State parameter mismatch. Possible CSRF attack detected.</p>
                                    <p>You can close this window and try again.</p>
                                </body>
                            </html>
                        `);
            this.stop();
            reject(new Error("State mismatch - possible CSRF attack"));
            return;
          }
          clearTimeout(timeout);
          res.writeHead(200, { "Content-Type": "text/html" });
          res.end(`
                        <html>
                            <body style="font-family: system-ui; padding: 40px; text-align: center;">
                                <h1>\u2705 Authentication Successful!</h1>
                                <p>You can close this window and return to Obsidian.</p>
                                <p style="color: #666; font-size: 14px; margin-top: 40px;">
                                    The Email to PARA Sync plugin is now connected to your account.
                                </p>
                            </body>
                        </html>
                    `);
          this.stop();
          resolve({ code, state });
        } else {
          res.writeHead(404, { "Content-Type": "text/plain" });
          res.end("Not Found");
        }
      });
    });
  }
  /**
   * Stop the OAuth callback server
   */
  stop() {
    if (this.server) {
      this.server.close();
      this.server = null;
      console.log("OAuth callback server stopped");
    }
  }
  /**
   * Get the callback URL for OAuth redirect
   */
  getCallbackUrl() {
    if (!this.port) {
      throw new Error("Server not started - call start() first");
    }
    return `http://127.0.0.1:${this.port}/callback`;
  }
};
function generateOAuthState() {
  const array = new Uint8Array(32);
  crypto.getRandomValues(array);
  return Array.from(array, (byte) => byte.toString(16).padStart(2, "0")).join("");
}

// src/GmailProvider.ts
var import_obsidian2 = require("obsidian");
var GmailProvider = class {
  constructor(settings) {
    this.name = "gmail";
    this.tokenData = null;
    this.settings = settings;
    if (settings.encryptedTokenBlob) {
      try {
        this.tokenData = JSON.parse(settings.encryptedTokenBlob);
      } catch (e) {
        console.error("Failed to parse Gmail token blob:", e);
      }
    }
  }
  isAuthenticated() {
    var _a;
    return !!((_a = this.tokenData) == null ? void 0 : _a.refreshToken);
  }
  async authenticate() {
    if (!this.settings.clientId) {
      throw new Error("Gmail Client ID not configured. Please enter it in settings.");
    }
    new import_obsidian2.Notice("Starting Gmail authentication...");
    console.log("GmailProvider: Starting OAuth flow...");
    const server = new OAuthServer();
    try {
      await server.start();
      const callbackUrl = server.getCallbackUrl();
      const state = generateOAuthState();
      const authParams = new URLSearchParams({
        client_id: this.settings.clientId,
        redirect_uri: callbackUrl,
        response_type: "code",
        scope: "https://www.googleapis.com/auth/gmail.readonly",
        state,
        access_type: "offline",
        // Get refresh token
        prompt: "consent"
        // Force consent screen to ensure refresh token
      });
      const authUrl = `https://accounts.google.com/o/oauth2/v2/auth?${authParams.toString()}`;
      console.log("Opening browser to:", authUrl);
      window.open(authUrl, "_blank");
      const result = await server.waitForCallback(state);
      const tokens = await this.exchangeCodeForTokens(result.code, callbackUrl);
      this.tokenData = {
        accessToken: tokens.access_token,
        refreshToken: tokens.refresh_token,
        expiresAt: Date.now() + tokens.expires_in * 1e3
      };
      this.settings.encryptedTokenBlob = JSON.stringify(this.tokenData);
      new import_obsidian2.Notice("Gmail authenticated successfully!");
      console.log("Gmail authentication successful");
    } catch (e) {
      console.error("Gmail authentication failed:", e);
      new import_obsidian2.Notice(`Gmail authentication failed: ${e.message}`);
      throw e;
    } finally {
      server.stop();
    }
  }
  async exchangeCodeForTokens(code, redirectUri) {
    const params = new URLSearchParams({
      code,
      client_id: this.settings.clientId,
      redirect_uri: redirectUri,
      grant_type: "authorization_code"
    });
    const response = await fetch("https://oauth2.googleapis.com/token", {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: params.toString()
    });
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Token exchange failed: ${response.status} - ${errorText}`);
    }
    return await response.json();
  }
  async getUserEmail() {
    return null;
  }
  async getStarredMessages(since) {
    if (!this.isAuthenticated()) {
      throw new Error("Gmail is not authenticated.");
    }
    await this.ensureAccessToken();
    try {
      let query = "q=is:starred";
      if (since) {
        const seconds = Math.floor(since.getTime() / 1e3);
        query += ` after:${seconds}`;
      }
      const listUrl = `https://gmail.googleapis.com/gmail/v1/users/me/messages?${query}`;
      const listRes = await fetch(listUrl, {
        headers: { "Authorization": `Bearer ${this.tokenData.accessToken}` }
      });
      if (!listRes.ok) {
        console.error("Gmail list failed", await listRes.text());
        return [];
      }
      const listData = await listRes.json();
      const messages = listData.messages || [];
      if (messages.length === 0)
        return [];
      const emailMessages = [];
      for (const msg of messages) {
        const detailUrl = `https://gmail.googleapis.com/gmail/v1/users/me/messages/${msg.id}?format=full`;
        const detailRes = await fetch(detailUrl, {
          headers: { "Authorization": `Bearer ${this.tokenData.accessToken}` }
        });
        if (detailRes.ok) {
          const data = await detailRes.json();
          emailMessages.push(this.parseGmailMessage(data));
        }
      }
      return emailMessages;
    } catch (e) {
      console.error("Error fetching Gmail messages:", e);
      return [];
    }
  }
  async ensureAccessToken() {
    if (!this.tokenData) {
      throw new Error("Not authenticated");
    }
    if (this.tokenData.expiresAt > Date.now() + 5 * 60 * 1e3) {
      return;
    }
    console.log("Gmail access token expired, refreshing...");
    const params = new URLSearchParams({
      refresh_token: this.tokenData.refreshToken,
      client_id: this.settings.clientId,
      grant_type: "refresh_token"
    });
    const response = await fetch("https://oauth2.googleapis.com/token", {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: params.toString()
    });
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Token refresh failed: ${response.status} - ${errorText}`);
    }
    const tokens = await response.json();
    this.tokenData.accessToken = tokens.access_token;
    this.tokenData.expiresAt = Date.now() + tokens.expires_in * 1e3;
    this.settings.encryptedTokenBlob = JSON.stringify(this.tokenData);
    console.log("Gmail access token refreshed successfully");
  }
  parseAddress(raw) {
    const match = raw.match(/(.*)<(.*)>/);
    if (match) {
      return { name: match[1].trim().replace(/^"|"$/g, ""), email: match[2].trim() };
    }
    return { name: raw.trim().replace(/^"|"$/g, ""), email: raw.trim() };
  }
  getAttachments(payload) {
    const attachments = [];
    const walk = (part) => {
      var _a;
      if (part.filename && ((_a = part.body) == null ? void 0 : _a.attachmentId)) {
        attachments.push({
          name: part.filename,
          contentType: part.mimeType,
          size: part.body.size || 0
        });
      }
      if (part.parts) {
        part.parts.forEach(walk);
      }
    };
    walk(payload);
    return attachments;
  }
  parseGmailMessage(data) {
    var _a, _b, _c, _d, _e, _f;
    const headers = ((_a = data.payload) == null ? void 0 : _a.headers) || [];
    const getHeader = (name) => {
      var _a2;
      return ((_a2 = headers.find((h) => h.name.toLowerCase() === name.toLowerCase())) == null ? void 0 : _a2.value) || "";
    };
    const subject = getHeader("subject") || "(No Subject)";
    const fromRaw = getHeader("from");
    const dateRaw = getHeader("date");
    const toRaw = getHeader("to");
    const ccRaw = getHeader("cc");
    const from = this.parseAddress(fromRaw);
    const parseAddressList = (listStr) => {
      if (!listStr)
        return [];
      return listStr.split(",").map((s) => this.parseAddress(s.trim()));
    };
    const to = parseAddressList(toRaw);
    const cc = parseAddressList(ccRaw);
    let bodyHtml = "";
    if ((_c = (_b = data.payload) == null ? void 0 : _b.body) == null ? void 0 : _c.data) {
      bodyHtml = Buffer.from(data.payload.body.data, "base64").toString("utf-8");
    } else if ((_d = data.payload) == null ? void 0 : _d.parts) {
      const htmlPart = data.payload.parts.find((p) => p.mimeType === "text/html");
      if ((_e = htmlPart == null ? void 0 : htmlPart.body) == null ? void 0 : _e.data) {
        bodyHtml = Buffer.from(htmlPart.body.data, "base64").toString("utf-8");
      } else {
        const textPart = data.payload.parts.find((p) => p.mimeType === "text/plain");
        if ((_f = textPart == null ? void 0 : textPart.body) == null ? void 0 : _f.data) {
          bodyHtml = Buffer.from(textPart.body.data, "base64").toString("utf-8");
        }
      }
    }
    const attachments = this.getAttachments(data.payload);
    return {
      id: data.id,
      source: "gmail",
      subject,
      from,
      to,
      cc,
      receivedAt: new Date(parseInt(data.internalDate)),
      snippet: data.snippet,
      bodyHtml,
      webLink: `https://mail.google.com/mail/u/0/#inbox/${data.id}`,
      hasAttachments: attachments.length > 0,
      attachments,
      labels: data.labelIds
    };
  }
};

// src/OutlookProvider.ts
var import_obsidian3 = require("obsidian");
var _OutlookProvider = class {
  constructor(settings) {
    this.name = "outlook";
    this.tokenData = null;
    this.settings = settings;
    if (settings.encryptedTokenBlob) {
      try {
        this.tokenData = JSON.parse(settings.encryptedTokenBlob);
      } catch (e) {
        console.error("Failed to parse Outlook token blob:", e);
      }
    }
  }
  isAuthenticated() {
    var _a;
    return !!((_a = this.tokenData) == null ? void 0 : _a.refreshToken);
  }
  async authenticate() {
    if (!this.settings.clientId) {
      throw new Error("Outlook Client ID not configured. Please enter it in settings.");
    }
    new import_obsidian3.Notice("Starting Outlook authentication...");
    console.log("OutlookProvider: Starting OAuth flow...");
    const server = new OAuthServer();
    try {
      await server.start();
      const callbackUrl = server.getCallbackUrl();
      const state = generateOAuthState();
      const scopes = ["openid", "profile", "offline_access", "User.Read", "Mail.Read"];
      const authParams = new URLSearchParams({
        client_id: this.settings.clientId,
        response_type: "code",
        redirect_uri: callbackUrl,
        response_mode: "query",
        scope: scopes.join(" "),
        state
      });
      const authUrl = `${_OutlookProvider.AUTH_ENDPOINT}?${authParams.toString()}`;
      console.log("Opening browser to:", authUrl);
      window.open(authUrl, "_blank");
      const result = await server.waitForCallback(state);
      await this.exchangeCodeForTokens(result.code, callbackUrl);
      new import_obsidian3.Notice("Outlook authenticated successfully!");
      console.log("Outlook authentication successful");
    } catch (e) {
      console.error("Outlook authentication failed:", e);
      new import_obsidian3.Notice(`Outlook authentication failed: ${e.message}`);
      throw e;
    } finally {
      server.stop();
    }
  }
  async exchangeCodeForTokens(code, redirectUri) {
    const body = new URLSearchParams({
      client_id: this.settings.clientId,
      scope: "openid profile offline_access User.Read Mail.Read",
      code,
      redirect_uri: redirectUri,
      grant_type: "authorization_code"
    });
    const response = await fetch(_OutlookProvider.TOKEN_ENDPOINT, {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: body.toString()
    });
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Token exchange failed: ${response.status} - ${errorText}`);
    }
    const data = await response.json();
    this.saveTokens(data);
  }
  saveTokens(data) {
    var _a;
    this.tokenData = {
      accessToken: data.access_token,
      refreshToken: data.refresh_token || ((_a = this.tokenData) == null ? void 0 : _a.refreshToken),
      // Keep old refresh token if new one not provided
      expiresAt: Date.now() + data.expires_in * 1e3
    };
    this.settings.encryptedTokenBlob = JSON.stringify(this.tokenData);
  }
  async getUserEmail() {
    var _a;
    if (!this.isAuthenticated())
      return null;
    try {
      await this.ensureAccessToken();
      const response = await fetch(`${_OutlookProvider.GRAPH_ENDPOINT}/me`, {
        headers: { "Authorization": `Bearer ${(_a = this.tokenData) == null ? void 0 : _a.accessToken}` }
      });
      if (response.ok) {
        const data = await response.json();
        return data.userPrincipalName || data.mail || null;
      }
    } catch (e) {
      console.error("Error fetching user email:", e);
    }
    return null;
  }
  async getStarredMessages(since) {
    var _a;
    if (!this.isAuthenticated()) {
      throw new Error("Outlook is not authenticated.");
    }
    await this.ensureAccessToken();
    try {
      let filter = "flag/flagStatus eq 'flagged'";
      if (since) {
        filter += ` and receivedDateTime ge ${since.toISOString()}`;
      }
      const select = "id,subject,receivedDateTime,from,toRecipients,ccRecipients,body,bodyPreview,webLink,hasAttachments,flag";
      const url = `${_OutlookProvider.GRAPH_ENDPOINT}/me/messages?$filter=${encodeURIComponent(filter)}&$select=${select}&$top=50`;
      const response = await fetch(url, {
        headers: { "Authorization": `Bearer ${(_a = this.tokenData) == null ? void 0 : _a.accessToken}` }
      });
      if (!response.ok) {
        console.error("Outlook list failed", await response.text());
        return [];
      }
      const data = await response.json();
      const messages = data.value || [];
      return messages.map((msg) => this.parseOutlookMessage(msg));
    } catch (e) {
      console.error("Error fetching Outlook messages:", e);
      return [];
    }
  }
  async ensureAccessToken() {
    if (!this.tokenData) {
      throw new Error("Not authenticated");
    }
    if (this.tokenData.expiresAt > Date.now() + 5 * 60 * 1e3) {
      return;
    }
    console.log("Outlook access token expired, refreshing...");
    const body = new URLSearchParams({
      client_id: this.settings.clientId,
      scope: "openid profile offline_access User.Read Mail.Read",
      refresh_token: this.tokenData.refreshToken,
      grant_type: "refresh_token"
    });
    const response = await fetch(_OutlookProvider.TOKEN_ENDPOINT, {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: body.toString()
    });
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Token refresh failed: ${response.status} - ${errorText}`);
    }
    const data = await response.json();
    this.saveTokens(data);
    console.log("Outlook access token refreshed successfully");
  }
  parseOutlookMessage(data) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const from = {
      name: ((_b = (_a = data.from) == null ? void 0 : _a.emailAddress) == null ? void 0 : _b.name) || ((_d = (_c = data.from) == null ? void 0 : _c.emailAddress) == null ? void 0 : _d.address) || "Unknown",
      email: ((_f = (_e = data.from) == null ? void 0 : _e.emailAddress) == null ? void 0 : _f.address) || ""
    };
    const mapRecipients = (recipients) => (recipients || []).map((r) => {
      var _a2, _b2, _c2;
      return {
        name: ((_a2 = r.emailAddress) == null ? void 0 : _a2.name) || ((_b2 = r.emailAddress) == null ? void 0 : _b2.address) || "",
        email: ((_c2 = r.emailAddress) == null ? void 0 : _c2.address) || ""
      };
    });
    const bodyHtml = ((_g = data.body) == null ? void 0 : _g.contentType) === "html" ? data.body.content : "";
    const bodyText = ((_h = data.body) == null ? void 0 : _h.contentType) === "text" ? data.body.content : "";
    return {
      id: data.id,
      source: "outlook",
      subject: data.subject || "(No Subject)",
      from,
      to: mapRecipients(data.toRecipients),
      cc: mapRecipients(data.ccRecipients),
      receivedAt: new Date(data.receivedDateTime),
      snippet: data.bodyPreview || "",
      bodyHtml,
      bodyText,
      webLink: data.webLink,
      hasAttachments: data.hasAttachments,
      labels: []
      // Outlook flags don't map neatly to labels like Gmail
    };
  }
};
var OutlookProvider = _OutlookProvider;
// Microsoft Graph Endpoints
OutlookProvider.AUTH_ENDPOINT = "https://login.microsoftonline.com/common/oauth2/v2.0/authorize";
OutlookProvider.TOKEN_ENDPOINT = "https://login.microsoftonline.com/common/oauth2/v2.0/token";
OutlookProvider.GRAPH_ENDPOINT = "https://graph.microsoft.com/v1.0";

// src/NoteCreator.ts
var import_obsidian4 = require("obsidian");

// node_modules/turndown/lib/turndown.browser.es.js
function extend(destination) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (source.hasOwnProperty(key))
        destination[key] = source[key];
    }
  }
  return destination;
}
function repeat(character, count) {
  return Array(count + 1).join(character);
}
function trimLeadingNewlines(string) {
  return string.replace(/^\n*/, "");
}
function trimTrailingNewlines(string) {
  var indexEnd = string.length;
  while (indexEnd > 0 && string[indexEnd - 1] === "\n")
    indexEnd--;
  return string.substring(0, indexEnd);
}
function trimNewlines(string) {
  return trimTrailingNewlines(trimLeadingNewlines(string));
}
var blockElements = [
  "ADDRESS",
  "ARTICLE",
  "ASIDE",
  "AUDIO",
  "BLOCKQUOTE",
  "BODY",
  "CANVAS",
  "CENTER",
  "DD",
  "DIR",
  "DIV",
  "DL",
  "DT",
  "FIELDSET",
  "FIGCAPTION",
  "FIGURE",
  "FOOTER",
  "FORM",
  "FRAMESET",
  "H1",
  "H2",
  "H3",
  "H4",
  "H5",
  "H6",
  "HEADER",
  "HGROUP",
  "HR",
  "HTML",
  "ISINDEX",
  "LI",
  "MAIN",
  "MENU",
  "NAV",
  "NOFRAMES",
  "NOSCRIPT",
  "OL",
  "OUTPUT",
  "P",
  "PRE",
  "SECTION",
  "TABLE",
  "TBODY",
  "TD",
  "TFOOT",
  "TH",
  "THEAD",
  "TR",
  "UL"
];
function isBlock(node) {
  return is(node, blockElements);
}
var voidElements = [
  "AREA",
  "BASE",
  "BR",
  "COL",
  "COMMAND",
  "EMBED",
  "HR",
  "IMG",
  "INPUT",
  "KEYGEN",
  "LINK",
  "META",
  "PARAM",
  "SOURCE",
  "TRACK",
  "WBR"
];
function isVoid(node) {
  return is(node, voidElements);
}
function hasVoid(node) {
  return has(node, voidElements);
}
var meaningfulWhenBlankElements = [
  "A",
  "TABLE",
  "THEAD",
  "TBODY",
  "TFOOT",
  "TH",
  "TD",
  "IFRAME",
  "SCRIPT",
  "AUDIO",
  "VIDEO"
];
function isMeaningfulWhenBlank(node) {
  return is(node, meaningfulWhenBlankElements);
}
function hasMeaningfulWhenBlank(node) {
  return has(node, meaningfulWhenBlankElements);
}
function is(node, tagNames) {
  return tagNames.indexOf(node.nodeName) >= 0;
}
function has(node, tagNames) {
  return node.getElementsByTagName && tagNames.some(function(tagName) {
    return node.getElementsByTagName(tagName).length;
  });
}
var rules = {};
rules.paragraph = {
  filter: "p",
  replacement: function(content) {
    return "\n\n" + content + "\n\n";
  }
};
rules.lineBreak = {
  filter: "br",
  replacement: function(content, node, options) {
    return options.br + "\n";
  }
};
rules.heading = {
  filter: ["h1", "h2", "h3", "h4", "h5", "h6"],
  replacement: function(content, node, options) {
    var hLevel = Number(node.nodeName.charAt(1));
    if (options.headingStyle === "setext" && hLevel < 3) {
      var underline = repeat(hLevel === 1 ? "=" : "-", content.length);
      return "\n\n" + content + "\n" + underline + "\n\n";
    } else {
      return "\n\n" + repeat("#", hLevel) + " " + content + "\n\n";
    }
  }
};
rules.blockquote = {
  filter: "blockquote",
  replacement: function(content) {
    content = trimNewlines(content).replace(/^/gm, "> ");
    return "\n\n" + content + "\n\n";
  }
};
rules.list = {
  filter: ["ul", "ol"],
  replacement: function(content, node) {
    var parent = node.parentNode;
    if (parent.nodeName === "LI" && parent.lastElementChild === node) {
      return "\n" + content;
    } else {
      return "\n\n" + content + "\n\n";
    }
  }
};
rules.listItem = {
  filter: "li",
  replacement: function(content, node, options) {
    var prefix = options.bulletListMarker + "   ";
    var parent = node.parentNode;
    if (parent.nodeName === "OL") {
      var start = parent.getAttribute("start");
      var index = Array.prototype.indexOf.call(parent.children, node);
      prefix = (start ? Number(start) + index : index + 1) + ".  ";
    }
    var isParagraph = /\n$/.test(content);
    content = trimNewlines(content) + (isParagraph ? "\n" : "");
    content = content.replace(/\n/gm, "\n" + " ".repeat(prefix.length));
    return prefix + content + (node.nextSibling ? "\n" : "");
  }
};
rules.indentedCodeBlock = {
  filter: function(node, options) {
    return options.codeBlockStyle === "indented" && node.nodeName === "PRE" && node.firstChild && node.firstChild.nodeName === "CODE";
  },
  replacement: function(content, node, options) {
    return "\n\n    " + node.firstChild.textContent.replace(/\n/g, "\n    ") + "\n\n";
  }
};
rules.fencedCodeBlock = {
  filter: function(node, options) {
    return options.codeBlockStyle === "fenced" && node.nodeName === "PRE" && node.firstChild && node.firstChild.nodeName === "CODE";
  },
  replacement: function(content, node, options) {
    var className = node.firstChild.getAttribute("class") || "";
    var language = (className.match(/language-(\S+)/) || [null, ""])[1];
    var code = node.firstChild.textContent;
    var fenceChar = options.fence.charAt(0);
    var fenceSize = 3;
    var fenceInCodeRegex = new RegExp("^" + fenceChar + "{3,}", "gm");
    var match;
    while (match = fenceInCodeRegex.exec(code)) {
      if (match[0].length >= fenceSize) {
        fenceSize = match[0].length + 1;
      }
    }
    var fence = repeat(fenceChar, fenceSize);
    return "\n\n" + fence + language + "\n" + code.replace(/\n$/, "") + "\n" + fence + "\n\n";
  }
};
rules.horizontalRule = {
  filter: "hr",
  replacement: function(content, node, options) {
    return "\n\n" + options.hr + "\n\n";
  }
};
rules.inlineLink = {
  filter: function(node, options) {
    return options.linkStyle === "inlined" && node.nodeName === "A" && node.getAttribute("href");
  },
  replacement: function(content, node) {
    var href = node.getAttribute("href");
    if (href)
      href = href.replace(/([()])/g, "\\$1");
    var title = cleanAttribute(node.getAttribute("title"));
    if (title)
      title = ' "' + title.replace(/"/g, '\\"') + '"';
    return "[" + content + "](" + href + title + ")";
  }
};
rules.referenceLink = {
  filter: function(node, options) {
    return options.linkStyle === "referenced" && node.nodeName === "A" && node.getAttribute("href");
  },
  replacement: function(content, node, options) {
    var href = node.getAttribute("href");
    var title = cleanAttribute(node.getAttribute("title"));
    if (title)
      title = ' "' + title + '"';
    var replacement;
    var reference;
    switch (options.linkReferenceStyle) {
      case "collapsed":
        replacement = "[" + content + "][]";
        reference = "[" + content + "]: " + href + title;
        break;
      case "shortcut":
        replacement = "[" + content + "]";
        reference = "[" + content + "]: " + href + title;
        break;
      default:
        var id = this.references.length + 1;
        replacement = "[" + content + "][" + id + "]";
        reference = "[" + id + "]: " + href + title;
    }
    this.references.push(reference);
    return replacement;
  },
  references: [],
  append: function(options) {
    var references = "";
    if (this.references.length) {
      references = "\n\n" + this.references.join("\n") + "\n\n";
      this.references = [];
    }
    return references;
  }
};
rules.emphasis = {
  filter: ["em", "i"],
  replacement: function(content, node, options) {
    if (!content.trim())
      return "";
    return options.emDelimiter + content + options.emDelimiter;
  }
};
rules.strong = {
  filter: ["strong", "b"],
  replacement: function(content, node, options) {
    if (!content.trim())
      return "";
    return options.strongDelimiter + content + options.strongDelimiter;
  }
};
rules.code = {
  filter: function(node) {
    var hasSiblings = node.previousSibling || node.nextSibling;
    var isCodeBlock = node.parentNode.nodeName === "PRE" && !hasSiblings;
    return node.nodeName === "CODE" && !isCodeBlock;
  },
  replacement: function(content) {
    if (!content)
      return "";
    content = content.replace(/\r?\n|\r/g, " ");
    var extraSpace = /^`|^ .*?[^ ].* $|`$/.test(content) ? " " : "";
    var delimiter = "`";
    var matches = content.match(/`+/gm) || [];
    while (matches.indexOf(delimiter) !== -1)
      delimiter = delimiter + "`";
    return delimiter + extraSpace + content + extraSpace + delimiter;
  }
};
rules.image = {
  filter: "img",
  replacement: function(content, node) {
    var alt = cleanAttribute(node.getAttribute("alt"));
    var src = node.getAttribute("src") || "";
    var title = cleanAttribute(node.getAttribute("title"));
    var titlePart = title ? ' "' + title + '"' : "";
    return src ? "![" + alt + "](" + src + titlePart + ")" : "";
  }
};
function cleanAttribute(attribute) {
  return attribute ? attribute.replace(/(\n+\s*)+/g, "\n") : "";
}
function Rules(options) {
  this.options = options;
  this._keep = [];
  this._remove = [];
  this.blankRule = {
    replacement: options.blankReplacement
  };
  this.keepReplacement = options.keepReplacement;
  this.defaultRule = {
    replacement: options.defaultReplacement
  };
  this.array = [];
  for (var key in options.rules)
    this.array.push(options.rules[key]);
}
Rules.prototype = {
  add: function(key, rule) {
    this.array.unshift(rule);
  },
  keep: function(filter) {
    this._keep.unshift({
      filter,
      replacement: this.keepReplacement
    });
  },
  remove: function(filter) {
    this._remove.unshift({
      filter,
      replacement: function() {
        return "";
      }
    });
  },
  forNode: function(node) {
    if (node.isBlank)
      return this.blankRule;
    var rule;
    if (rule = findRule(this.array, node, this.options))
      return rule;
    if (rule = findRule(this._keep, node, this.options))
      return rule;
    if (rule = findRule(this._remove, node, this.options))
      return rule;
    return this.defaultRule;
  },
  forEach: function(fn) {
    for (var i = 0; i < this.array.length; i++)
      fn(this.array[i], i);
  }
};
function findRule(rules2, node, options) {
  for (var i = 0; i < rules2.length; i++) {
    var rule = rules2[i];
    if (filterValue(rule, node, options))
      return rule;
  }
  return void 0;
}
function filterValue(rule, node, options) {
  var filter = rule.filter;
  if (typeof filter === "string") {
    if (filter === node.nodeName.toLowerCase())
      return true;
  } else if (Array.isArray(filter)) {
    if (filter.indexOf(node.nodeName.toLowerCase()) > -1)
      return true;
  } else if (typeof filter === "function") {
    if (filter.call(rule, node, options))
      return true;
  } else {
    throw new TypeError("`filter` needs to be a string, array, or function");
  }
}
function collapseWhitespace(options) {
  var element = options.element;
  var isBlock2 = options.isBlock;
  var isVoid2 = options.isVoid;
  var isPre = options.isPre || function(node2) {
    return node2.nodeName === "PRE";
  };
  if (!element.firstChild || isPre(element))
    return;
  var prevText = null;
  var keepLeadingWs = false;
  var prev = null;
  var node = next(prev, element, isPre);
  while (node !== element) {
    if (node.nodeType === 3 || node.nodeType === 4) {
      var text = node.data.replace(/[ \r\n\t]+/g, " ");
      if ((!prevText || / $/.test(prevText.data)) && !keepLeadingWs && text[0] === " ") {
        text = text.substr(1);
      }
      if (!text) {
        node = remove(node);
        continue;
      }
      node.data = text;
      prevText = node;
    } else if (node.nodeType === 1) {
      if (isBlock2(node) || node.nodeName === "BR") {
        if (prevText) {
          prevText.data = prevText.data.replace(/ $/, "");
        }
        prevText = null;
        keepLeadingWs = false;
      } else if (isVoid2(node) || isPre(node)) {
        prevText = null;
        keepLeadingWs = true;
      } else if (prevText) {
        keepLeadingWs = false;
      }
    } else {
      node = remove(node);
      continue;
    }
    var nextNode = next(prev, node, isPre);
    prev = node;
    node = nextNode;
  }
  if (prevText) {
    prevText.data = prevText.data.replace(/ $/, "");
    if (!prevText.data) {
      remove(prevText);
    }
  }
}
function remove(node) {
  var next2 = node.nextSibling || node.parentNode;
  node.parentNode.removeChild(node);
  return next2;
}
function next(prev, current, isPre) {
  if (prev && prev.parentNode === current || isPre(current)) {
    return current.nextSibling || current.parentNode;
  }
  return current.firstChild || current.nextSibling || current.parentNode;
}
var root = typeof window !== "undefined" ? window : {};
function canParseHTMLNatively() {
  var Parser = root.DOMParser;
  var canParse = false;
  try {
    if (new Parser().parseFromString("", "text/html")) {
      canParse = true;
    }
  } catch (e) {
  }
  return canParse;
}
function createHTMLParser() {
  var Parser = function() {
  };
  {
    if (shouldUseActiveX()) {
      Parser.prototype.parseFromString = function(string) {
        var doc = new window.ActiveXObject("htmlfile");
        doc.designMode = "on";
        doc.open();
        doc.write(string);
        doc.close();
        return doc;
      };
    } else {
      Parser.prototype.parseFromString = function(string) {
        var doc = document.implementation.createHTMLDocument("");
        doc.open();
        doc.write(string);
        doc.close();
        return doc;
      };
    }
  }
  return Parser;
}
function shouldUseActiveX() {
  var useActiveX = false;
  try {
    document.implementation.createHTMLDocument("").open();
  } catch (e) {
    if (root.ActiveXObject)
      useActiveX = true;
  }
  return useActiveX;
}
var HTMLParser = canParseHTMLNatively() ? root.DOMParser : createHTMLParser();
function RootNode(input, options) {
  var root2;
  if (typeof input === "string") {
    var doc = htmlParser().parseFromString(
      // DOM parsers arrange elements in the <head> and <body>.
      // Wrapping in a custom element ensures elements are reliably arranged in
      // a single element.
      '<x-turndown id="turndown-root">' + input + "</x-turndown>",
      "text/html"
    );
    root2 = doc.getElementById("turndown-root");
  } else {
    root2 = input.cloneNode(true);
  }
  collapseWhitespace({
    element: root2,
    isBlock,
    isVoid,
    isPre: options.preformattedCode ? isPreOrCode : null
  });
  return root2;
}
var _htmlParser;
function htmlParser() {
  _htmlParser = _htmlParser || new HTMLParser();
  return _htmlParser;
}
function isPreOrCode(node) {
  return node.nodeName === "PRE" || node.nodeName === "CODE";
}
function Node(node, options) {
  node.isBlock = isBlock(node);
  node.isCode = node.nodeName === "CODE" || node.parentNode.isCode;
  node.isBlank = isBlank(node);
  node.flankingWhitespace = flankingWhitespace(node, options);
  return node;
}
function isBlank(node) {
  return !isVoid(node) && !isMeaningfulWhenBlank(node) && /^\s*$/i.test(node.textContent) && !hasVoid(node) && !hasMeaningfulWhenBlank(node);
}
function flankingWhitespace(node, options) {
  if (node.isBlock || options.preformattedCode && node.isCode) {
    return { leading: "", trailing: "" };
  }
  var edges = edgeWhitespace(node.textContent);
  if (edges.leadingAscii && isFlankedByWhitespace("left", node, options)) {
    edges.leading = edges.leadingNonAscii;
  }
  if (edges.trailingAscii && isFlankedByWhitespace("right", node, options)) {
    edges.trailing = edges.trailingNonAscii;
  }
  return { leading: edges.leading, trailing: edges.trailing };
}
function edgeWhitespace(string) {
  var m = string.match(/^(([ \t\r\n]*)(\s*))(?:(?=\S)[\s\S]*\S)?((\s*?)([ \t\r\n]*))$/);
  return {
    leading: m[1],
    // whole string for whitespace-only strings
    leadingAscii: m[2],
    leadingNonAscii: m[3],
    trailing: m[4],
    // empty for whitespace-only strings
    trailingNonAscii: m[5],
    trailingAscii: m[6]
  };
}
function isFlankedByWhitespace(side, node, options) {
  var sibling;
  var regExp;
  var isFlanked;
  if (side === "left") {
    sibling = node.previousSibling;
    regExp = / $/;
  } else {
    sibling = node.nextSibling;
    regExp = /^ /;
  }
  if (sibling) {
    if (sibling.nodeType === 3) {
      isFlanked = regExp.test(sibling.nodeValue);
    } else if (options.preformattedCode && sibling.nodeName === "CODE") {
      isFlanked = false;
    } else if (sibling.nodeType === 1 && !isBlock(sibling)) {
      isFlanked = regExp.test(sibling.textContent);
    }
  }
  return isFlanked;
}
var reduce = Array.prototype.reduce;
var escapes = [
  [/\\/g, "\\\\"],
  [/\*/g, "\\*"],
  [/^-/g, "\\-"],
  [/^\+ /g, "\\+ "],
  [/^(=+)/g, "\\$1"],
  [/^(#{1,6}) /g, "\\$1 "],
  [/`/g, "\\`"],
  [/^~~~/g, "\\~~~"],
  [/\[/g, "\\["],
  [/\]/g, "\\]"],
  [/^>/g, "\\>"],
  [/_/g, "\\_"],
  [/^(\d+)\. /g, "$1\\. "]
];
function TurndownService(options) {
  if (!(this instanceof TurndownService))
    return new TurndownService(options);
  var defaults = {
    rules,
    headingStyle: "setext",
    hr: "* * *",
    bulletListMarker: "*",
    codeBlockStyle: "indented",
    fence: "```",
    emDelimiter: "_",
    strongDelimiter: "**",
    linkStyle: "inlined",
    linkReferenceStyle: "full",
    br: "  ",
    preformattedCode: false,
    blankReplacement: function(content, node) {
      return node.isBlock ? "\n\n" : "";
    },
    keepReplacement: function(content, node) {
      return node.isBlock ? "\n\n" + node.outerHTML + "\n\n" : node.outerHTML;
    },
    defaultReplacement: function(content, node) {
      return node.isBlock ? "\n\n" + content + "\n\n" : content;
    }
  };
  this.options = extend({}, defaults, options);
  this.rules = new Rules(this.options);
}
TurndownService.prototype = {
  /**
   * The entry point for converting a string or DOM node to Markdown
   * @public
   * @param {String|HTMLElement} input The string or DOM node to convert
   * @returns A Markdown representation of the input
   * @type String
   */
  turndown: function(input) {
    if (!canConvert(input)) {
      throw new TypeError(
        input + " is not a string, or an element/document/fragment node."
      );
    }
    if (input === "")
      return "";
    var output = process.call(this, new RootNode(input, this.options));
    return postProcess.call(this, output);
  },
  /**
   * Add one or more plugins
   * @public
   * @param {Function|Array} plugin The plugin or array of plugins to add
   * @returns The Turndown instance for chaining
   * @type Object
   */
  use: function(plugin) {
    if (Array.isArray(plugin)) {
      for (var i = 0; i < plugin.length; i++)
        this.use(plugin[i]);
    } else if (typeof plugin === "function") {
      plugin(this);
    } else {
      throw new TypeError("plugin must be a Function or an Array of Functions");
    }
    return this;
  },
  /**
   * Adds a rule
   * @public
   * @param {String} key The unique key of the rule
   * @param {Object} rule The rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  addRule: function(key, rule) {
    this.rules.add(key, rule);
    return this;
  },
  /**
   * Keep a node (as HTML) that matches the filter
   * @public
   * @param {String|Array|Function} filter The unique key of the rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  keep: function(filter) {
    this.rules.keep(filter);
    return this;
  },
  /**
   * Remove a node that matches the filter
   * @public
   * @param {String|Array|Function} filter The unique key of the rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  remove: function(filter) {
    this.rules.remove(filter);
    return this;
  },
  /**
   * Escapes Markdown syntax
   * @public
   * @param {String} string The string to escape
   * @returns A string with Markdown syntax escaped
   * @type String
   */
  escape: function(string) {
    return escapes.reduce(function(accumulator, escape) {
      return accumulator.replace(escape[0], escape[1]);
    }, string);
  }
};
function process(parentNode) {
  var self = this;
  return reduce.call(parentNode.childNodes, function(output, node) {
    node = new Node(node, self.options);
    var replacement = "";
    if (node.nodeType === 3) {
      replacement = node.isCode ? node.nodeValue : self.escape(node.nodeValue);
    } else if (node.nodeType === 1) {
      replacement = replacementForNode.call(self, node);
    }
    return join(output, replacement);
  }, "");
}
function postProcess(output) {
  var self = this;
  this.rules.forEach(function(rule) {
    if (typeof rule.append === "function") {
      output = join(output, rule.append(self.options));
    }
  });
  return output.replace(/^[\t\r\n]+/, "").replace(/[\t\r\n\s]+$/, "");
}
function replacementForNode(node) {
  var rule = this.rules.forNode(node);
  var content = process.call(this, node);
  var whitespace = node.flankingWhitespace;
  if (whitespace.leading || whitespace.trailing)
    content = content.trim();
  return whitespace.leading + rule.replacement(content, node, this.options) + whitespace.trailing;
}
function join(output, replacement) {
  var s1 = trimTrailingNewlines(output);
  var s2 = trimLeadingNewlines(replacement);
  var nls = Math.max(output.length - s1.length, replacement.length - s2.length);
  var separator = "\n\n".substring(0, nls);
  return s1 + separator + s2;
}
function canConvert(input) {
  return input != null && (typeof input === "string" || input.nodeType && (input.nodeType === 1 || input.nodeType === 9 || input.nodeType === 11));
}
var turndown_browser_es_default = TurndownService;

// src/HtmlToMarkdown.ts
var HtmlToMarkdown = class {
  constructor() {
    this.turndownService = new turndown_browser_es_default({
      headingStyle: "atx",
      hr: "---",
      bulletListMarker: "-",
      codeBlockStyle: "fenced",
      fence: "```",
      emDelimiter: "*",
      strongDelimiter: "**",
      linkStyle: "inlined",
      linkReferenceStyle: "collapsed"
    });
    this.turndownService.remove("script");
  }
  /**
   * Converts an HTML string to a Markdown string.
   * @param html The HTML content to convert.
   * @returns The converted Markdown content.
   */
  convert(html) {
    return this.turndownService.turndown(html);
  }
};

// src/NoteCreator.ts
var NoteCreator = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
    this.markdownConverter = new HtmlToMarkdown();
  }
  /**
   * Creates a new note in the vault from an email message.
   */
  async createNote(email) {
    const inboxFolder = this.settings.sync.inboxFolder || "0 - INBOX";
    if (!this.app.vault.getAbstractFileByPath(inboxFolder)) {
      try {
        await this.app.vault.createFolder(inboxFolder);
      } catch (e) {
        console.error(`Failed to create inbox folder: ${inboxFolder}`, e);
        return null;
      }
    }
    const filename = await this.generateUniqueFilename(email, inboxFolder);
    const content = this.generateNoteContent(email);
    try {
      const file = await this.app.vault.create(filename, content);
      return file;
    } catch (e) {
      console.error(`Failed to create note for email ${email.id}`, e);
      return null;
    }
  }
  /**
   * Generates a unique filename based on date and subject.
   * Format: YYYY-MM-DD - Subject.md
   */
  async generateUniqueFilename(email, folder) {
    const dateStr = email.receivedAt.toISOString().split("T")[0];
    const safeSubject = this.sanitizeFilename(email.subject).substring(0, 100);
    let basename = `${dateStr} - ${safeSubject}`;
    let fullPath = (0, import_obsidian4.normalizePath)(`${folder}/${basename}.md`);
    let counter = 1;
    while (this.app.vault.getAbstractFileByPath(fullPath)) {
      fullPath = (0, import_obsidian4.normalizePath)(`${folder}/${basename} (${counter}).md`);
      counter++;
    }
    return fullPath;
  }
  sanitizeFilename(name) {
    return name.replace(/[\\/:*?"<>|]/g, "-").trim();
  }
  generateNoteContent(email) {
    const bodyMarkdown = this.markdownConverter.convert(email.bodyHtml);
    const dateFormatted = email.receivedAt.toLocaleString();
    const safeSubject = email.subject.split('"').join('"');
    const frontmatter = [
      "---",
      "tags: [all, para/inbox, email-task]",
      `created: ${email.receivedAt.toISOString().split("T")[0]}`,
      `email-source: ${email.source}`,
      `email-id: "${email.id}"`,
      `email-from: "${email.from.email}"`,
      `email-subject: "${safeSubject}"`,
      `email-date: ${email.receivedAt.toISOString()}`,
      `email-link: "${email.webLink}"`,
      `synced: ${new Date().toISOString()}`,
      "---"
    ].join("\n");
    const content = [
      frontmatter,
      "",
      `# Subject: ${email.subject}`,
      "",
      `**From:** ${email.from.name} <${email.from.email}>`,
      `**Date:** ${dateFormatted}`,
      `**Source:** [View in ${email.source === "gmail" ? "Gmail" : "Outlook"}](${email.webLink})`,
      "",
      "---",
      "",
      "## Email Content",
      "",
      bodyMarkdown,
      "",
      "---",
      "",
      "## Tasks",
      "",
      "- [ ] ",
      "",
      "## Notes",
      "",
      ""
    ].join("\n");
    return content;
  }
};

// main.ts
var EmailToParaPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    this.syncIntervalId = null;
    this.isSyncing = false;
  }
  async onload() {
    console.log("Loading Email to PARA Sync Plugin");
    await this.loadSettings();
    this.syncStateManager = new SyncStateManager(this);
    await this.syncStateManager.load();
    this.gmailProvider = new GmailProvider(this.settings.gmail);
    this.outlookProvider = new OutlookProvider(this.settings.outlook);
    this.noteCreator = new NoteCreator(this.app, this.settings);
    this.addSettingTab(new EmailToParaSettingTab(this.app, this));
    this.statusBarItem = this.addStatusBarItem();
    this.statusBarItem.setText("Email Sync: Ready");
    this.addRibbonIcon("mail", "Sync emails", async (evt) => {
      new import_obsidian5.Notice("Starting email sync...");
      await this.syncEmails();
    });
    this.addCommand({
      id: "sync-emails-manually",
      name: "Sync Emails Manually",
      callback: async () => {
        new import_obsidian5.Notice("Starting email sync...");
        await this.syncEmails();
      }
    });
    this.startAutoSync();
  }
  async onunload() {
    console.log("Unloading Email to PARA Sync Plugin");
    this.stopAutoSync();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    if (this.gmailProvider)
      this.gmailProvider = new GmailProvider(this.settings.gmail);
    if (this.outlookProvider)
      this.outlookProvider = new OutlookProvider(this.settings.outlook);
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.stopAutoSync();
    this.startAutoSync();
  }
  startAutoSync() {
    if (this.syncIntervalId) {
      window.clearInterval(this.syncIntervalId);
    }
    const intervalMs = this.settings.sync.intervalMinutes * 60 * 1e3;
    console.log(`Email Sync: Auto-sync started (Interval: ${this.settings.sync.intervalMinutes}m)`);
    this.syncIntervalId = window.setInterval(() => {
      this.syncEmails();
    }, intervalMs);
  }
  stopAutoSync() {
    if (this.syncIntervalId) {
      window.clearInterval(this.syncIntervalId);
      this.syncIntervalId = null;
    }
  }
  async syncEmails() {
    if (this.isSyncing) {
      console.log("Email Sync: Sync already in progress. Skipping.");
      return;
    }
    this.isSyncing = true;
    this.statusBarItem.setText("Email Sync: Checking...");
    let newCount = 0;
    let errorCount = 0;
    try {
      const providers = [];
      if (this.settings.gmail.enabled)
        providers.push(this.gmailProvider);
      if (this.settings.outlook.enabled)
        providers.push(this.outlookProvider);
      if (providers.length === 0) {
        console.log("Email Sync: No providers enabled.");
        this.statusBarItem.setText("Email Sync: Off");
        this.isSyncing = false;
        return;
      }
      for (const provider of providers) {
        try {
          if (!provider.isAuthenticated()) {
            console.log(`Email Sync: ${provider.name} enabled but not authenticated.`);
            continue;
          }
          const lastSync = this.syncStateManager.getLastSyncTime();
          const messages = await provider.getStarredMessages(lastSync > 0 ? new Date(lastSync) : void 0);
          for (const msg of messages) {
            if (this.syncStateManager.isSynced(msg.id)) {
              continue;
            }
            const file = await this.noteCreator.createNote(msg);
            if (file) {
              await this.syncStateManager.addSynced(msg.id);
              newCount++;
            } else {
              errorCount++;
            }
          }
        } catch (e) {
          console.error(`Email Sync: Error syncing ${provider.name}`, e);
          errorCount++;
          new import_obsidian5.Notice(`Email Sync Error (${provider.name}): ${e.message}`);
        }
      }
      await this.syncStateManager.setLastSyncTime(Date.now());
      if (newCount > 0) {
        new import_obsidian5.Notice(`Email Sync: Created ${newCount} new notes.`);
      } else if (errorCount > 0) {
        new import_obsidian5.Notice(`Email Sync: Finished with ${errorCount} errors.`);
      } else {
        console.log("Email Sync: No new emails.");
      }
    } catch (e) {
      console.error("Email Sync: Critical Error", e);
      new import_obsidian5.Notice("Email Sync Failed");
    } finally {
      this.isSyncing = false;
      const timeStr = new Date().toLocaleTimeString();
      this.statusBarItem.setText(`Email Sync: Done ${timeStr}`);
    }
  }
};
